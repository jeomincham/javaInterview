     
     
   对于一个无序列，我们想要将它转换成有序列，所谓的有序列为升序（由小到大）或者降序（由大到小），要完成这样的排序，有很多种排序算法，下面介绍其中一种：冒泡排序。
冒泡排序的原理为：`以升序为例，将相邻的两个元素进行比较，如果前面一个元素比后面一个元素大，则两者进行进行交换` 。后面的以此类推，下面进行图解。

比如现在有一个数组为：int[] num = {6,5,9,1,2,4};现在要将这个数组中的元素排列为升序排列：1,2,4,5,6,9

根据冒泡排序的原理：数组中的元素用相邻（下标相邻）的两个元素进行比较，如果前面比后面的值大，则交换：

+ 第一趟排序：6,5,9,1,2,4

　　第一次比较：6和5比较，前面6比后面5大，则两者交换，交换后结果为：5,6,9,1,2,4        （每次得到的结果用于下一次比较）

　　第二次比较：6和9比较，前面6比后面9小，则两者不交换，结果为：5,6,9,1,2,4

　　第三次比较：9和1比较，前面9比后面1大，则两者交换，交换后结果为:5,6,1,9,2,4

　　第四次比较：9和2比较，前面9比后面2大，则两者交换，交换后结果为：5,6,1,2,9,4

　　第五次比较：9和4比较，前面9比后面4大，则两者交换，交换后结果为：5,6,1,2,4,9

以上是第一趟排序，数组一共有6个元素，相邻的两个比较，一共比较了5次，当一趟排序完成之后，最大值9已经在最后面了，那么下次比较将不用再做比较了。

+ 第二趟排序：5,6,1,2,4,9

　　第一次比较：5和6比较，前面5比后面6小，则两者不交换，结果为：5,6,1,2,4,9

　　第二次比较：6和1比较，前面6比后面1大，则两者交换，结果为：5,1,6,2,4,9

　　第三次比较：6和2比较，前面6比后面2大，则两者交换，结果为：5,1,2,6,4,9

　　第四次比较：6和4比较，前面6比后面4大，则两者交换，结果为5,1,2,4,6,9

+ 第三趟排序：5,1,2,4,6,9

　　第一次比较：5和1比较，前面5比后面1大，则两者交换，交换后结果为：1,5,2,4,6,9

　　第二次比较：5和2比较，前面5比后面2大，则两者交换，交换后结果为：1,2,5,4,6,9

　　第三次比较：5和4比较，前面5比后面4大，则两者交换，交换后结果为：1,2,4,5,6,9

+ 第四趟排序：1,2,4,5,6,9 （可能有人会认为，这里已经得到正确的排序了，后面就不需要再排序了，不能这么理解，因为我们数组的值不一定每次都是这几个数字，因此还是需要继续比较完）

　　第一次比较：1和2比较，前面1比后面2小，则两者不交换，结果为：1,2,4,5,6,9

　　第二次比较：2和4比较，前面2比后面4小，则两者不交换，结果为：1,2,4,5,6,9

第五趟排序：1,2,4,5,6,9

　　第一次比较：1和2比较，前面1比后面2小，则两者比较换，结果为：1,2,4,5,6,9

以上就是对数组中的元素进行比较分析，下面是图示：

![img](https://img2018.cnblogs.com/blog/1361241/201901/1361241-20190125153933041-559300294.png)

通过文字说明和图示说明，我们可以很轻松的写出每一趟相邻两个数比较的代码：

```
1 for(int i =0;i < num.length-1;i++){
2   //实现相邻的两个数进行比较
3   if(num[i] > num[i+1]){
4     //前面比后面的数大，则两者进行交换
5     int temp = num[i];
6     num[i] = num[i+1];
7     num[i+1] = num[i];    
8   }    
9 }    
```


执行完上面的代码后，代表的是一趟排序，可以完成一趟以内，相邻的两个数进行比较，也就是说要完成冒泡排序，只要将上面的代码执行5次就可以了，

但是还是有问题，单从代码上面阅读来看，循环完以上代码，一定会比较5次，但是实际上，根据图示可以很清楚的看出来，每多一趟排序，则少比较一次。

那么一下才是完整的冒泡排序：

```
 1 public void bubble(){
 2   //定义一个数组：
 3   int[] num = {6,5,9,1,2,4};
 4   //使用循环：外层循环表示需要排序多少趟,num.length-1=5,保证进行5次排序
 5   for(int i = 0;i < num.length-1;i++){
 6      //使用循环，完成每一趟排序中的所有比较，注意：每多比较一趟，则少比较一次
 7      for(int j = 0;j < num.length-1-i;j++){
 8         //两个相邻的两个数进行比较：
 9         if(num[j] > num[j+1]){
10              //前面的数比后面的数大，则交换
11              int temp = num[j];
12              num[j] = num[j+1];
13              num[j+1] = temp;
14          }
15      }
16   }  
17 }
```

注意：阅读以下上面的代码

第一个for循环：i < num.length-1;目的是为了让实现排序的趟数比数组长度少1，比如上面6个元素的数组，只需要排序5次

第二个for循环：表示每一趟排序中，相邻两个数的比较，j < num.length-1-i;这个减少i是什么意思呢减i是为了实现，每多一趟排序，则相邻的两个数比较次数减少一次，而i又是从0开始的。

如果还不明白，阅读以下代码流程：

第一趟排序：

　　当i = 0  则num.length-1-i = 5    很容易得出第二个循环会循环5次，也就是说会有5组相邻的两个数进行比较

　　当i = 1，则num.length-1-i = 4   则第二个for循环会循环4次，也就是说会有4组相邻的两个数进行比较

　　当i = 2    则num.length-1-i = 3   则第二个for循环会循环3次，也就是说会有3组相邻的两个数进行比较

​    当i = 3    则num.length-1-i = 2   则第二个for循环会循环2次，也就是说会有3组相邻的两个数进行比较

​    当i = 4    则num.length-1-i = 1   则第二个for循环会循环1尺，也就是说会有3组相邻的两个数进行比较

所以：第一个for循环是控制我们需要排序多少趟，而第二个for循环是控制我们在每一趟中需要多少次相邻两个数进行比较。

 

